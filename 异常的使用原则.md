# 异常

checkedException

uncheckedException 方法声明中不强制 throw，也不必须 try-catch

两者最大的区别在于，checked Exception 可恢复（修复）；unchecked Exception 不可恢复，例如 JVM 抛出的异常。



# 异常的使用原则

不特指，下面异常均值 checkedException

1. 不用异常控制正常流程，只在不正常的情况下使用异常

   - 补充说明：抛出异常的逻辑开销高于正常控制流

2. 可恢复的条件用 checkedException，不可恢复的用 uncheckedException，这里主要是指 RuntimeException

3. 使用 checkedException 必须满足两个条件。

   1. 即使正确使用 api 也不能阻止异常的产生
   2. 一旦产生异常，使用 api 的程序员可以进行有用的处理（去恢复）

   **这点主要是针对基础建设的开发的，比如框架开发的时候**

4. 尽量使用标准异常

5. 抛出的异常要适合当前的抽象。使用异常转译。

   - 例如，通过索引去某种容器里获取一个元素，得到了一个“元素不存在的异常”，如果这个时候你在写一个有序型容器，你可以在捕获这个异常之后抛出“索引越界异常”，这更符合当前场景的抽象

6. 异常都需要文档。使用 @throws 记录每个异常被抛出的条件

7. 捕获的异常都应该有失败消息（原因）。形式可以是异常发生的类，发生的原因。

8. 失败应保证原子性。抛出异常后，对象应该是保证一个好的状态，方便调用者在一个正常状态下继续操作。具体措施：

   1. 执行前检查。再转变为错误的状态前，先抛出异常，中断执行
   2. 状态回滚。编写恢复的代码
   3. 对象临时拷贝，操作完后再赋值给对象

   总的来说，任何一个异常都不应该改变对象调用该方法之前的状态，如果违反，文档中应该指明对象将会变成什么状态

9. 不要忽略异常。即 catch 为空处理（从调用者角度）



# 实际的应用

如果是要写框架或者基础建设。那么 checkedException 是非常好的设计。但是必须要清楚其代价以及缺点，比如说实现的修改，导致 throws 异常的增加，这在调用者看来是灾难性的事情（解决方案可以考虑用异常包装）

但是如果是业务实现单用 checkedException 和 uncheckedException 都是有利有弊的。uncheckedException 由于不强制抛出异常，业务主流程（代码可读写）更加的清晰，但是千万不能忘记对极限情况下异常的处理。checkedException，能避免的情况下，尽量不使用，不抛出。捕获的情况下，尽量去恢复，不能忽视。



