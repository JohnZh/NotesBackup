# 垃圾回收基础知识



标记算法：

- 引用计数
- gcroot，当前 jvm 都已经是 gcroot
  - 关键点在于 root 的选择：
    - 线程栈引用（栈帧局部变量表）指向的对象
    - 方法区静态变量、常量指向的对象
    - 本地方法栈引用指向的对象

标记回收算法：

- 标记清除 mark-swap
  - 扫描 2 次，一次标记一次删除
  - 缺点：碎片多，两次扫描效率低
  - 适用：存活对象多的时候效率高，因此适合**老年代**
- 拷贝 copying
  - 内存分为两部分（存活区和回收区），遍历一次，存活的就移动到存活区，剩下回收区就全回收
  - 缺点：内存空间浪费，移动对象需要调整引用内实际地址
  - 适用：存活对象少的时候效率高，因此适合 **Eden**
- 标记压缩 mark-campact
  - 扫描 2 次，一次扫描，一次压缩（存活对象移动到内存头部），并且引用地址要调整
  - 缺点：效率偏低；优点：无碎片，无内存浪费
  - 适用：存活对象多的**老年代**



JVM 堆内存逻辑分区：2 个区域（1：2）

- 年轻代（Eden + S1+ S2）
- 老年代



年轻代什么时候进入老年代？

取决于垃圾回收器，一般两种方案：

1. 指定参数：XX:MaxTenuringThreshold，不会超过 15（对象头 4 bit）
2. 动态年龄，s1 -> s2，s2 对象超过 50%，年龄最大的放入 Old



# 垃圾回收器常见组合

- Serial + Serial Old，非常老的垃圾回收器，现代 JVM 很少使用
- PS+PO（Parallel Scavenge + Parallel Old）， 现代 JVM 默认
- ParNew + CMS（Parallel New + Concurrent Mark Sweep）J2EE 一般不用这个



## CMS 工作流程

1. 初始标记（STW）
2. 并发标记（会有漏标问题，步骤 3 会解决掉）
3. 重新标记（STW）
4. 并发清理（会有浮动垃圾问题，下次标记处理）



## CMS 的问题

- PromotionFaild：

老年代的垃圾回收器，使用 mark-swap 算法，先天就有“内存碎片化”的问题。当发生 GC 的时候，年轻代的对象发生向老年代的转移，但是老年代由于内存碎片，无法给年轻代的对象提供内存空间，就会使用 Serial Old 进行 mark-compact 标记压缩。由于 Serial Old 是单线程，耗时严重，这个过程也叫 FGC。

- ConcurrentModeFailure：

产生原因：老年代填满之前并发垃圾回收器就无法完成不可达对象（垃圾）的回收，或者可用空间不能满足分配。实际上也是浮动垃圾和内存碎片的问题。这个问题也会导致 FGC。



CMS 的问题如何解决（优化）呢？

降低触发 CMS 的阈值。即除了留给浮动垃圾的空间外留多少空间。比如阈值 96%，留给浮动垃圾的空间为 4%。



# 并发标记算法

## G1 的基础知识

G1，物理不分代，逻辑分代；其他的垃圾回收器，物理分代逻辑分代

G1 的新老年代的区域是动态调整的

G1，内存模型，基础单元 Region：代表逻辑分代，Eden，Survivor，Old，Humongous（超过 Region 的 50% 或者跨多个 Region）

Region 大小：1/2/4.../32M（2 的幂）

> 补充：
>
> 分代模型中，内存都会被分成 Card（不管是年轻代还是老年代）一个 card 里面有多个对象，如果老年代中有一个 card 里面的对象指回年轻代，那么这个 Card 会被标记为 dirty。具体的标记使用一个 BitMap（1 位标记一个 card）这个 BitMap 叫作 Card Table。而在垃圾回收器扫描标记的时候，就可以避免老年代所有对象的扫描，而是只扫描 dirty 的 Card
>
> CSet：Collection Set：记录需要被回收的 Card
>
> RSet：Remember Set：每个 Region 里面都有一个 hashset，记录其他 Region 的对象到本 Region 的引用。使得垃圾回收器不需要扫描整个堆就找到谁引用了当前分区的对象（三色标记算法的核心）

## 三色标记算法

并发标记过程中的三色：

- 黑色：自身和成员变量均已标记完

- 灰色：自身被标记，成员变量未标记

- 白色：未被标记的对象



对象漏标的产生条件：

1. 黑色对象有成员变量指向了白色对象
2. 灰色对象的成员变量删除了对这个白色对象的引用。

这个时候这个白色对象就会被回收



解决方案：

- （CMS）incremental update 增量更新，关注引用增加：黑色重新标记为灰色。这会导致这些黑色对象会需要重新扫描（标记）一次。
- （G1）snapshot at the beginning(SATB)，关注引用删除：灰色指向白色的引用消失时候，黑色指向白色引用会被 push 到堆栈（GC 线程）。再重新标记阶段，由于 RSet 的存在，可以直接查看是否有引用指向这个白色对象，以此来判断是否要回收。



# Ref

笔记：https://www.jianshu.com/p/c0769aafa436

